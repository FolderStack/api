import {
    HttpBadRequestError
} from '@common/errors';
import { Ok, response } from '@common/responses';
import { withSentryTrace } from '@common/sentry';
import { logger } from '@common/utils';
import { APIGatewayProxyEvent } from 'aws-lambda';
import * as TE from 'fp-ts/TaskEither';
import { pipe } from 'fp-ts/lib/function';
import { attestationFlow } from '../lib/attestation/';
import { getClientByBundleId, getClientDataByChallenge } from '../lib/db';

async function handler(event: APIGatewayProxyEvent) {
    try {
        const body = JSON.parse(event.body ?? '{}');

        /**
         * JWT formatted data provided by the Apple 
         * device.
         */
        const attestation = body.attestation;
        /**
         * A challenge previously generated by the 
         * `retrieveAttestationChallenge` function.
         */
        const challenge = body.challenge;
        /**
         * A unique device id. This is provided by
         * the app and we expect the app to retain
         * a copy.
         */
        const device = body.device;
        /**
         * The Key ID of the key pair generated on
         * the apple device with DeviceCheck/
         * AppAttest.
         */
        const localKeyId = body.keyId;
        /**
         * The bundle ID of the iOS app requesting
         * attestation.
         * 
         * Looks like `com.company.appname`
         */
        const bundleId = body.bundleId;

        if (!localKeyId || !device || !challenge || !attestation || !bundleId) {
            return new HttpBadRequestError().toResponse();
        }

        return pipe(
            getClientDataByChallenge(challenge, device),
            TE.chain(() => getClientByBundleId(bundleId)),
            TE.chain((client) => {
                return attestationFlow(
                    attestation,
                    String(challenge),
                    String(device),
                    String(localKeyId),
                    client
                )
            }),
            response(Ok)
        )();
    } catch (err: any) {
        logger.warn(err?.message, err);
    }
}

export const tracedHandler = withSentryTrace(handler);
